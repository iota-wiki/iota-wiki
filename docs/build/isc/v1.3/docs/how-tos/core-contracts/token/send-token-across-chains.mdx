---
description: How to Send Native Tokens Across Chains.
image: /img/logo/WASP_logo_dark.png
tags:
  - EVM
  - how-to
  - native tokens
  - cross-chain
---
import ExampleCodeIntro from '../../../_partials/how-tos/token/_example_code_intro.md';
import DemoTokenSetup from '../../../_admonitions/_token-demo-setup.md';
import CreateNativeToken from '../../../_admonitions/_create-native-token.md';

# Send Native Token Across Chains

In this guide, you'll learn how to send L1 native Tokens from L1 to an L2 EVM account on a destination chain by using the `sendCrossChain` function of the `NativeTokenController.sol` contract.

<CreateNativeToken/>

## Understanding the `sendCrossChain` Function

First, letâ€™s take a look at the `sendCrossChain` function in the `NativeTokenController.sol` file:

```solidity
function sendCrossChain(
        address destinationChain,
        bytes memory destinationAddress,
        uint256 amount,
        ISCChainID chainID,
        uint64 storageDeposit
) external {
    // Function implementation
}
```

This function facilitates the transfer of a specified `amount` of tokens from the current chain to a `destinationChain`, with the `destinationAddress` as the recipient on the destination chain. The `sendCrossChain` function invokes the `ISC.sandbox.send` function, which manages the actual cross-chain message transmission.

## Setting Up the Development Environment

<DemoTokenSetup/>

## Using the `sendCrossChain` Function

To send native tokens across chains, you need to provide the following transaction details to the `sendCrossChain` function. 

* `ChainAddress` - The L1 address of the destination chain.
* `Destination` - The address on the destination chain that will receive the tokens.
* `chainID` - The ID of the destination chain.
* `amount` - The amount of native tokens to sent.
* `storageDeposit` - The base tokens to cover storage deposit.

## Example Code
<ExampleCodeIntro/>

### 2. Send Token to Another Chain

Let's define a function named `sendCrossChainMessage` in our contract, which will interact with the `sendCrossChain` function in the `NativeTokenController` contract.

```solidity
    function sendCrossChainMessage(
        address destinationChain,
        bytes memory destinationAddress,
        uint256 amount,
        ISCChainID chainID,
        uint64 storageDeposit
    ) external {
        // Ensure the sender has enough tokens (assuming a balanceOf function exists)
        uint256 senderBalance = IERC20(tokenAddress).balanceOf(msg.sender);
        require(senderBalance >= amount, "Insufficient token balance");

        // Call the sendCrossChain function from NativeTokenController
        nativeTokenController.sendCrossChain(destinationChain, destinationAddress, amount, chainID, storageDeposit);
    }
```

# Full Example Code

```solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./NativeTokenController.sol";  // Adjust the path as necessary

contract CrossChainMessenger {

    NativeTokenController public nativeTokenController;

    constructor(address _nativeTokenControllerAddress) {
        nativeTokenController = NativeTokenController(_nativeTokenControllerAddress);
    }

    function sendCrossChainMessage(
        address destinationChain,
        bytes memory destinationAddress,
        uint256 amount,
        ISCChainID chainID,
        uint64 storageDeposit
    ) external {
        // Ensure the sender has enough tokens (assuming a balanceOf function exists)
        uint256 senderBalance = IERC20(tokenAddress).balanceOf(msg.sender);
        require(senderBalance >= amount, "Insufficient token balance");

        // Call the sendCrossChain function from NativeTokenController
        nativeTokenController.sendCrossChain(destinationChain, destinationAddress, amount, chainID, storageDeposit);
    }
}
```